package acceptance

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// UnboundSentinel is the marker placed in generated test stubs that have not
// yet been bound to a real implementation.
const UnboundSentinel = `t.Fatal("acceptance test not yet bound")`

// sanitizeFuncName converts a description into a valid Go test function name suffix.
func sanitizeFuncName(desc string) string {
	// Replace non-alphanumeric characters with underscores
	re := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	name := re.ReplaceAllString(desc, "_")
	// Trim trailing underscores
	name = strings.TrimRight(name, "_")
	return name
}

// funcSignatureRe matches "func Test_...(t *testing.T) {" at column 0.
var funcSignatureRe = regexp.MustCompile(`^func (Test_\w+)\(t \*testing\.T\) \{`)

// ExtractBoundFunctions scans Go source for test functions at column 0 and
// returns a map of funcName â†’ full text (including preceding comments) for
// functions that do NOT contain the UnboundSentinel.
func ExtractBoundFunctions(source string) map[string]string {
	result := make(map[string]string)
	if source == "" {
		return result
	}

	lines := strings.Split(source, "\n")
	i := 0
	for i < len(lines) {
		m := funcSignatureRe.FindStringSubmatch(lines[i])
		if m == nil {
			i++
			continue
		}

		funcName := m[1]

		// Collect preceding comment lines
		commentStart := i
		for commentStart > 0 && strings.HasPrefix(strings.TrimSpace(lines[commentStart-1]), "//") {
			commentStart--
		}

		// Collect function body through closing } at column 0 using brace depth
		depth := 1
		bodyEnd := i + 1
		for bodyEnd < len(lines) && depth > 0 {
			for _, ch := range lines[bodyEnd] {
				if ch == '{' {
					depth++
				} else if ch == '}' {
					depth--
				}
			}
			bodyEnd++
		}

		// Build the full function text (comments + signature + body)
		funcText := strings.Join(lines[commentStart:bodyEnd], "\n")

		// Only include if it does NOT contain the unbound sentinel
		if !strings.Contains(funcText, UnboundSentinel) {
			result[funcName] = funcText
		}

		i = bodyEnd
	}

	return result
}

// ExtractImports finds the import block in Go source and returns it as-is.
// Returns "" if no import block is found.
func ExtractImports(source string) string {
	if source == "" {
		return ""
	}

	lines := strings.Split(source, "\n")
	for i, line := range lines {
		if strings.TrimSpace(line) == "import (" {
			// Find matching closing paren
			for j := i + 1; j < len(lines); j++ {
				if strings.TrimSpace(lines[j]) == ")" {
					return strings.Join(lines[i:j+1], "\n")
				}
			}
		}
	}
	return ""
}

// GenerateTests transforms a Feature into executable Go test source code.
// If existingSource is non-empty, bound test implementations (those not
// containing UnboundSentinel) are preserved across regeneration.
// Stubs are regenerated; bound implementations are preserved.
func GenerateTests(feature *Feature, existingSource string) (string, error) {
	var b strings.Builder

	boundFuncs := ExtractBoundFunctions(existingSource)
	existingImports := ExtractImports(existingSource)

	fmt.Fprintf(&b, "// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.\n")
	fmt.Fprintf(&b, "// Source: %s\n\n", feature.SourceFile)
	fmt.Fprintf(&b, "package acceptance_test\n\n")

	// Emit import block
	if len(feature.Scenarios) > 0 || len(boundFuncs) > 0 {
		if existingImports != "" && len(boundFuncs) > 0 {
			fmt.Fprintf(&b, "%s\n", existingImports)
		} else {
			fmt.Fprintf(&b, "import (\n")
			fmt.Fprintf(&b, "\t\"testing\"\n")
			fmt.Fprintf(&b, ")\n")
		}
	}

	// Track which bound functions have been emitted
	emitted := make(map[string]bool)

	for _, scenario := range feature.Scenarios {
		funcName := "Test_" + sanitizeFuncName(scenario.Description)

		if boundText, ok := boundFuncs[funcName]; ok {
			// Emit preserved bound function
			fmt.Fprintf(&b, "\n%s\n", boundText)
			emitted[funcName] = true
		} else {
			// Emit stub
			fmt.Fprintf(&b, "\n// %s\n", scenario.Description)
			fmt.Fprintf(&b, "// Source: %s:%d\n", feature.SourceFile, scenario.Line)
			fmt.Fprintf(&b, "func %s(t *testing.T) {\n", funcName)
			for _, step := range scenario.Steps {
				fmt.Fprintf(&b, "\t// %s %s\n", step.Keyword, step.Text)
			}
			fmt.Fprintf(&b, "\n")
			fmt.Fprintf(&b, "\t%s\n", UnboundSentinel)
			fmt.Fprintf(&b, "}\n")
		}
	}

	// Emit orphaned bound functions (in existing but not in current spec)
	var orphans []string
	for name, text := range boundFuncs {
		if !emitted[name] {
			orphans = append(orphans, text)
		}
	}
	if len(orphans) > 0 {
		fmt.Fprintf(&b, "\n// WARNING: The following bound functions are orphaned (no matching scenario in current spec).\n")
		fmt.Fprintf(&b, "// They are preserved to prevent data loss. Remove manually if no longer needed.\n")
		for _, orphan := range orphans {
			fmt.Fprintf(&b, "\n%s\n", orphan)
		}
	}

	return b.String(), nil
}

// WriteTestFileImpl writes generated test code to disk, creating directories as needed.
// This is an Impl function exempt from coverage requirements.
func WriteTestFileImpl(path string, content string) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}
