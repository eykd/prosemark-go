// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt

package acceptance_test

import (
	"strings"
	"testing"
)

// Binder with one top-level chapter link is parsed into a tree.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:2
func Test_Binder_with_one_top_level_chapter_link_is_parsed_into_a_tree(t *testing.T) {
	// GIVEN a binder file containing one list item with a chapter link.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [Chapter One](chapter-one.md)\n")
	writeFile(t, dir, "chapter-one.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN the outline contains a single chapter node.
	if !result.OK {
		t.Fatalf("expected exit 0, got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	if !strings.Contains(result.Stdout, `"type":"node"`) {
		t.Errorf("expected a chapter node in output, got: %s", result.Stdout)
	}
	// THEN the chapter node has the title and file path from the link.
	if !strings.Contains(result.Stdout, `"title":"Chapter One"`) {
		t.Errorf("expected title 'Chapter One' in output, got: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"target":"chapter-one.md"`) {
		t.Errorf("expected target 'chapter-one.md' in output, got: %s", result.Stdout)
	}
}

// Binder using wiki-style links is parsed correctly.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:12
func Test_Binder_using_wiki_style_links_is_parsed_correctly(t *testing.T) {
	// GIVEN a binder file with a wiki-style link to a chapter file.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [[chapter-two]]\n")
	writeFile(t, dir, "chapter-two.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN the chapter node title is the name of the file without extension.
	if !result.OK {
		t.Fatalf("expected exit 0, got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	if !strings.Contains(result.Stdout, `"title":"chapter-two"`) {
		t.Errorf("expected title 'chapter-two' (stem) in output, got: %s", result.Stdout)
	}
	// THEN the chapter node path points to the matching file in the project.
	if !strings.Contains(result.Stdout, `"target":"chapter-two.md"`) {
		t.Errorf("expected target 'chapter-two.md' in output, got: %s", result.Stdout)
	}
}

// Binder using footnote-style links is parsed correctly.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:22
func Test_Binder_using_footnote_style_links_is_parsed_correctly(t *testing.T) {
	// GIVEN a binder file with a footnote-style chapter link and its matching definition.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [My Chapter][ch]\n\n[ch]: chapter-three.md\n")
	writeFile(t, dir, "chapter-three.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN the chapter node has the correct title and file path from the link definition.
	if !result.OK {
		t.Fatalf("expected exit 0, got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	if !strings.Contains(result.Stdout, `"title":"My Chapter"`) {
		t.Errorf("expected title 'My Chapter' in output, got: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"target":"chapter-three.md"`) {
		t.Errorf("expected target 'chapter-three.md' in output, got: %s", result.Stdout)
	}
}

// Binder without a version marker produces a warning.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:31
func Test_Binder_without_a_version_marker_produces_a_warning(t *testing.T) {
	// GIVEN a binder file with no version marker at the top.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"- [Chapter One](chapter-one.md)\n")
	writeFile(t, dir, "chapter-one.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN parsing succeeds.
	if !result.OK {
		t.Fatalf("expected exit 0 (warning is non-fatal), got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	// THEN a "missing version marker" warning is included in the result.
	if !strings.Contains(result.Stdout, `"BNDW001"`) {
		t.Errorf("expected BNDW001 warning in output, got: %s", result.Stdout)
	}
}

// Binder with illegal characters in a file path produces an error.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:41
func Test_Binder_with_illegal_characters_in_a_file_path_produces_an_error(t *testing.T) {
	// GIVEN a binder file with a chapter link whose path contains angle-bracket characters.
	// Using percent-encoding (%3E = ">") which the parser decodes before validation.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [Chapter](chapter%3Efile.md)\n")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN an "illegal path characters" error is included in the result.
	if result.OK {
		t.Fatalf("expected non-zero exit for illegal path, got exit 0\nstdout: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"BNDE001"`) {
		t.Errorf("expected BNDE001 error in output, got: %s", result.Stdout)
	}
}

// Binder with a path that escapes the project root produces an error.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:50
func Test_Binder_with_a_path_that_escapes_the_project_root_produces_an_error(t *testing.T) {
	// GIVEN a binder file with a chapter link that navigates above the project folder using dot-dot path segments.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [Chapter](../outside.md)\n")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN a "path escapes project root" error is included in the result.
	if result.OK {
		t.Fatalf("expected non-zero exit for path escape, got exit 0\nstdout: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"BNDE002"`) {
		t.Errorf("expected BNDE002 error in output, got: %s", result.Stdout)
	}
}

// Binder with a path matching a file only by different letter-case produces a warning.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:59
func Test_Binder_with_a_path_matching_a_file_only_by_different_letter_case_produces_a_warning(t *testing.T) {
	// GIVEN a binder file with a chapter link whose exact path does not exist but a file
	// with the same name in different letter-case does. Uses a wiki-style link so that the
	// parser performs case-insensitive basename resolution.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [[Chapter-Two]]\n")
	// file in lowercase; wikilink stem is in mixed case.
	writeFile(t, dir, "chapter-two.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN a "case-insensitive match only" warning is included in the result.
	if !result.OK {
		t.Fatalf("expected exit 0 (warning is non-fatal), got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	if !strings.Contains(result.Stdout, `"BNDW009"`) {
		t.Errorf("expected BNDW009 warning in output, got: %s", result.Stdout)
	}
}

// Binder with a wiki-style link matching files in two equally-distant folders produces an error.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:68
func Test_Binder_with_a_wiki_style_link_matching_files_in_two_equally_distant_folders_produces_an_error(t *testing.T) {
	// GIVEN a binder file with a wiki-style link whose name matches files in two different folders at the same depth.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n- [[ambiguous]]\n")
	// Two files with the same stem at equal depth (one slash each).
	writeFile(t, dir, "a/ambiguous.md", "")
	writeFile(t, dir, "b/ambiguous.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN an "ambiguous link" error is included in the result.
	if result.OK {
		t.Fatalf("expected non-zero exit for ambiguous wikilink, got exit 0\nstdout: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"BNDE003"`) {
		t.Errorf("expected BNDE003 error in output, got: %s", result.Stdout)
	}
}

// Links inside code blocks are excluded from the outline.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:77
func Test_Links_inside_code_blocks_are_excluded_from_the_outline(t *testing.T) {
	// GIVEN a binder file with a chapter link that appears inside a fenced code block.
	dir := t.TempDir()
	fence := "```"
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n"+
			fence+"\n"+
			"- [Chapter One](chapter-one.md)\n"+
			fence+"\n")
	writeFile(t, dir, "chapter-one.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	if !result.OK {
		t.Fatalf("expected exit 0 (BNDW005 is a warning), got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	// THEN that link is not included as a chapter node in the outline.
	if strings.Contains(result.Stdout, `"target":"chapter-one.md"`) {
		t.Errorf("link inside code block should not appear as a chapter node, got: %s", result.Stdout)
	}
	// THEN a "link found inside code block" warning is included in the result.
	if !strings.Contains(result.Stdout, `"BNDW005"`) {
		t.Errorf("expected BNDW005 warning in output, got: %s", result.Stdout)
	}
}

// Binder files with Windows-style line endings are parsed correctly.
// Source: specs/001-prosemark-binder/US1-parse-binder-file.txt:87
func Test_Binder_files_with_Windows_style_line_endings_are_parsed_correctly(t *testing.T) {
	// GIVEN a binder file whose lines end with Windows-style line endings.
	dir := t.TempDir()
	// Write a binder file with CRLF line endings throughout.
	crlfContent := "<!-- prosemark-binder:v1 -->\r\n- [Chapter One](chapter-one.md)\r\n"
	writeFile(t, dir, "_binder.md", crlfContent)
	writeFile(t, dir, "chapter-one.md", "")

	// WHEN the author requests the parsed outline.
	result := runParse(t, dir+"/_binder.md")

	// THEN the outline is extracted correctly.
	if !result.OK {
		t.Fatalf("expected exit 0 for CRLF binder, got error\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	if !strings.Contains(result.Stdout, `"title":"Chapter One"`) {
		t.Errorf("expected title 'Chapter One' in output, got: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"target":"chapter-one.md"`) {
		t.Errorf("expected target 'chapter-one.md' in output, got: %s", result.Stdout)
	}
	// THEN any written output preserves the original Windows-style line endings.
	// Note: the parse command emits JSON (which uses LF); CRLF round-trip preservation
	// is verified by the serializer unit tests. Here we confirm parse succeeds without
	// any CRLF-related diagnostic errors.
	if strings.Contains(result.Stdout, `"severity":"error"`) {
		t.Errorf("expected no errors for CRLF binder, got: %s", result.Stdout)
	}
}
