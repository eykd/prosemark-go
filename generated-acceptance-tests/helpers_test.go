// Package acceptance_test contains acceptance tests generated from GWT specs.
// This file provides shared helpers used across generated test files.
// It is NOT generated by the acceptance pipeline and will not be overwritten.
package acceptance_test

import (
	"bytes"
	"os"
	"os/exec"
	"path/filepath"
	"testing"
)

// runResult holds the separated output of a pmk command execution.
type runResult struct {
	Stdout string
	Stderr string
	OK     bool // true if exit code 0
}

// runGoCmd runs `go <args>` from the repository root (one directory above this
// test package) and returns the captured output.
func runGoCmd(t *testing.T, args ...string) runResult {
	t.Helper()
	cmd := exec.Command("go", args...)
	cmd.Dir = ".."
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	err := cmd.Run()
	return runResult{
		Stdout: stdout.String(),
		Stderr: stderr.String(),
		OK:     err == nil,
	}
}

// runPMK runs `go run . <args>` from the repository root, invoking the pmk CLI.
func runPMK(t *testing.T, args ...string) runResult {
	t.Helper()
	return runGoCmd(t, append([]string{"run", "."}, args...)...)
}

// writeFile writes content to dir/name, creating parent directories as needed,
// and returns the absolute path.
func writeFile(t *testing.T, dir, name, content string) string {
	t.Helper()
	path := filepath.Join(dir, name)
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		t.Fatalf("mkdir %s: %v", filepath.Dir(path), err)
	}
	if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
		t.Fatalf("writeFile %s: %v", name, err)
	}
	return path
}

// runParse invokes "pmk parse --project <dir>".
// binderPath is the path to the _binder.md file; the project dir is derived from it.
func runParse(t *testing.T, binderPath string) runResult {
	t.Helper()
	return runPMK(t, "parse", "--project", filepath.Dir(binderPath))
}

// runAddChild invokes "pmk add --project <dir>" with any extra flag strings appended.
// binderPath is the path to the _binder.md file; the project dir is derived from it.
func runAddChild(t *testing.T, binderPath string, extraArgs ...string) runResult {
	t.Helper()
	args := append([]string{"add", "--project", filepath.Dir(binderPath)}, extraArgs...)
	return runPMK(t, args...)
}

// runDelete invokes "pmk delete --selector <sel> --project <dir>"
// and optionally "--yes" if yes is true.
// binderPath is the path to the _binder.md file; the project dir is derived from it.
func runDelete(t *testing.T, binderPath, selector string, yes bool) runResult {
	t.Helper()
	args := []string{"delete", "--selector", selector, "--project", filepath.Dir(binderPath)}
	if yes {
		args = append(args, "--yes")
	}
	return runPMK(t, args...)
}

// runMove invokes "pmk move --source <source> --dest <dest> --project <dir>"
// with any extra flag strings appended.
// binderPath is the path to the _binder.md file; the project dir is derived from it.
func runMove(t *testing.T, binderPath, source, dest string, extraArgs ...string) runResult {
	t.Helper()
	args := append([]string{"move", "--source", source, "--dest", dest, "--project", filepath.Dir(binderPath)}, extraArgs...)
	return runPMK(t, args...)
}

// runConformance runs the conformance test suite with the given test filter.
func runConformance(t *testing.T, filter string) runResult {
	t.Helper()
	return runGoCmd(t, "test", "-run", filter, "-timeout", "120s", "./conformance/...")
}

// readFile reads the contents of path and returns it as a string.
func readFile(t *testing.T, path string) string {
	t.Helper()
	data, err := os.ReadFile(path)
	if err != nil {
		t.Fatalf("readFile %s: %v", path, err)
	}
	return string(data)
}
