// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt

package acceptance_test

import (
	"strings"
	"testing"
)

// New chapter is appended after all existing chapters by default.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:2
func Test_New_chapter_is_appended_after_all_existing_chapters_by_default(t *testing.T) {
	// GIVEN a binder with one existing top-level chapter.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n- [Chapter One](ch1.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch2.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds a new chapter at the top level using default placement.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "ch2.md", "--title", "Ch Two")

	// THEN the new chapter appears after the existing chapter.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	ch1Idx := strings.Index(content, "ch1.md")
	ch2Idx := strings.Index(content, "ch2.md")
	if ch1Idx < 0 || ch2Idx < 0 {
		t.Fatalf("expected both ch1.md and ch2.md in binder\ncontent: %s", content)
	}
	if ch2Idx <= ch1Idx {
		t.Errorf("expected ch2.md to appear after ch1.md\ncontent: %s", content)
	}
}

// New chapter is inserted before all existing chapters when first position is requested.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:11
func Test_New_chapter_is_inserted_before_all_existing_chapters_when_first_position_is_requested(t *testing.T) {
	// GIVEN a binder with several top-level chapters.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Ch One](ch1.md)\n"+
			"- [Ch Two](ch2.md)\n"+
			"- [Ch Three](ch3.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch2.md", "")
	writeFile(t, dir, "ch3.md", "")
	writeFile(t, dir, "new.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds a new chapter at the first position.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "new.md", "--first")

	// THEN the new chapter appears before all existing chapters.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	newIdx := strings.Index(content, "new.md")
	ch1Idx := strings.Index(content, "ch1.md")
	if newIdx < 0 || ch1Idx < 0 {
		t.Fatalf("expected new.md and ch1.md in binder\ncontent: %s", content)
	}
	if newIdx >= ch1Idx {
		t.Errorf("expected new.md before ch1.md (--first)\ncontent: %s", content)
	}
}

// New chapter is inserted at a specific numbered position.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:20
func Test_New_chapter_is_inserted_at_a_specific_numbered_position(t *testing.T) {
	// GIVEN a binder with several top-level chapters.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Ch One](ch1.md)\n"+
			"- [Ch Two](ch2.md)\n"+
			"- [Ch Three](ch3.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch2.md", "")
	writeFile(t, dir, "ch3.md", "")
	writeFile(t, dir, "new.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds a new chapter at position one, counting from zero.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "new.md", "--at", "1")

	// THEN the new chapter appears at position one in the list.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	ch1Idx := strings.Index(content, "ch1.md")
	newIdx := strings.Index(content, "new.md")
	ch2Idx := strings.Index(content, "ch2.md")
	if ch1Idx < 0 || newIdx < 0 || ch2Idx < 0 {
		t.Fatalf("expected all chapters in binder\ncontent: %s", content)
	}
	// new.md at index 1: after ch1 but before ch2
	if !(ch1Idx < newIdx && newIdx < ch2Idx) {
		t.Errorf("expected ch1.md < new.md < ch2.md (--at 1)\ncontent: %s", content)
	}
}

// New chapter is inserted before a named sibling.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:29
func Test_New_chapter_is_inserted_before_a_named_sibling(t *testing.T) {
	// GIVEN a binder with chapters named "A", "B", and "C".
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [A](a.md)\n"+
			"- [B](b.md)\n"+
			"- [C](c.md)\n")
	writeFile(t, dir, "a.md", "")
	writeFile(t, dir, "b.md", "")
	writeFile(t, dir, "c.md", "")
	writeFile(t, dir, "new.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds a new chapter before "B".
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "new.md", "--before", "b.md")

	// THEN the new chapter appears between "A" and "B".
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	aIdx := strings.Index(content, "a.md")
	newIdx := strings.Index(content, "new.md")
	bIdx := strings.Index(content, "b.md")
	if aIdx < 0 || newIdx < 0 || bIdx < 0 {
		t.Fatalf("expected a.md, new.md, b.md in binder\ncontent: %s", content)
	}
	if !(aIdx < newIdx && newIdx < bIdx) {
		t.Errorf("expected a.md < new.md < b.md\ncontent: %s", content)
	}
}

// Adding a chapter that already exists in the same parent is skipped with a warning.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:38
func Test_Adding_a_chapter_that_already_exists_in_the_same_parent_is_skipped_with_a_warning(t *testing.T) {
	// GIVEN a binder where the new chapter's file is already listed under the target parent.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n- [Chapter One](ch1.md)\n")
	writeFile(t, dir, "ch1.md", "")
	binderPath := dir + "/_binder.md"
	before := readFile(t, binderPath)

	// WHEN the author adds the chapter again without the force option.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "ch1.md")

	// THEN the binder is unchanged.
	if !result.OK {
		t.Fatalf("expected exit 0 (duplicate skipped is a warning)\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	// THEN a "duplicate skipped" warning is included in the result.
	if !strings.Contains(result.Stderr, "OPW002") {
		t.Errorf("expected OPW002 duplicate-skipped warning\nstderr: %s", result.Stderr)
	}
	after := readFile(t, binderPath)
	if before != after {
		t.Errorf("expected binder to be unchanged\nbefore: %s\nafter: %s", before, after)
	}
}

// Adding a duplicate chapter with the force option inserts a second copy.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:48
func Test_Adding_a_duplicate_chapter_with_the_force_option_inserts_a_second_copy(t *testing.T) {
	// GIVEN a binder where the new chapter's file is already listed under the target parent.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n- [Chapter One](ch1.md)\n")
	writeFile(t, dir, "ch1.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds the chapter again with the force option.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "ch1.md", "--force")

	// THEN the binder now contains two entries for that chapter file.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	count := strings.Count(content, "ch1.md")
	if count < 2 {
		t.Errorf("expected two entries for ch1.md with --force, got %d\ncontent: %s", count, content)
	}
}

// New chapter inherits the numbered list style of its siblings.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:57
func Test_New_chapter_inherits_the_numbered_list_style_of_its_siblings(t *testing.T) {
	// GIVEN a binder where existing chapters are arranged in a numbered list with period markers.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n1. [Chapter One](ch1.md)\n2. [Chapter Two](ch2.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch2.md", "")
	writeFile(t, dir, "ch3.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds a new chapter.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "ch3.md", "--title", "Chapter Three")

	// THEN the new chapter uses the next sequential number with the same period marker style.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, "ch3.md") {
		t.Errorf("expected ch3.md in binder\ncontent: %s", content)
	}
	if !strings.Contains(content, "3.") {
		t.Errorf("expected numbered marker '3.' for new chapter\ncontent: %s", content)
	}
}

// New chapter inherits the tab indentation of its siblings.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:66
func Test_New_chapter_inherits_the_tab_indentation_of_its_siblings(t *testing.T) {
	// GIVEN a binder where existing nested chapters are indented with tabs.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n- [Part](part.md)\n\t- [Chapter One](ch1.md)\n")
	writeFile(t, dir, "part.md", "")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch2.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author adds a new nested chapter.
	result := runAddChild(t, binderPath, "--parent", "part.md", "--target", "ch2.md", "--title", "Chapter Two")

	// THEN the new chapter is indented with tabs to match its siblings.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, "\t- [Chapter Two](ch2.md)") {
		t.Errorf("expected tab-indented new chapter '\\t- [Chapter Two](ch2.md)'\ncontent: %q", content)
	}
}

// A chapter title containing square bracket characters is stored with those characters escaped.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:75
func Test_A_chapter_title_containing_square_bracket_characters_is_stored_with_those_characters_escaped(t *testing.T) {
	// GIVEN the author wants to add a chapter whose title contains square bracket characters.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n- [Chapter One](ch1.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the chapter is added to the binder.
	result := runAddChild(t, binderPath, "--parent", ".", "--target", "ch.md", "--title", "A [note]")

	// THEN the stored title has those square bracket characters properly escaped.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, "ch.md") {
		t.Errorf("expected ch.md in binder\ncontent: %s", content)
	}
	// Square brackets in link text must be escaped: \[ and \]
	if !strings.Contains(content, `\[note\]`) {
		t.Errorf("expected escaped brackets '\\[note\\]' in stored title\ncontent: %s", content)
	}
}

// Attempting to add a chapter to a non-existent parent returns an error.
// Source: specs/001-prosemark-binder/US2-add-child-node.txt:84
func Test_Attempting_to_add_a_chapter_to_a_non_existent_parent_returns_an_error(t *testing.T) {
	// GIVEN a selector that does not match any node in the binder.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n- [Chapter One](ch1.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "n.md", "")
	binderPath := dir + "/_binder.md"
	before := readFile(t, binderPath)

	// WHEN the author tries to add a chapter under that selector as parent.
	result := runAddChild(t, binderPath, "--parent", "missing.md", "--target", "n.md")

	// THEN a "not found" error is returned.
	if result.OK {
		t.Fatalf("expected non-zero exit for non-existent parent\nstdout: %s", result.Stdout)
	}
	if !strings.Contains(result.Stderr, "OPE001") {
		t.Errorf("expected OPE001 not-found error\nstderr: %s", result.Stderr)
	}
	// THEN the binder is unchanged.
	after := readFile(t, binderPath)
	if before != after {
		t.Errorf("expected binder unchanged on error\nbefore: %s\nafter: %s", before, after)
	}
}
