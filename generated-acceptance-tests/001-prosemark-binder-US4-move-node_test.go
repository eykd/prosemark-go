// Code generated by acceptance-pipeline. Stubs are regenerated; bound implementations are preserved.
// Source: specs/001-prosemark-binder/US4-move-node.txt

package acceptance_test

import (
	"strings"
	"testing"
)

// Moving a chapter to a different position reorders the binder.
// Source: specs/001-prosemark-binder/US4-move-node.txt:2
func Test_Moving_a_chapter_to_a_different_position_reorders_the_binder(t *testing.T) {
	// GIVEN a binder with two sibling chapters in a certain order.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Chapter One](ch1.md)\n"+
			"- [Chapter Two](ch2.md)\n"+
			"- [Chapter Three](ch3.md)\n")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "ch2.md", "")
	writeFile(t, dir, "ch3.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author moves one chapter to the other's position.
	result := runMove(t, binderPath, "ch3.md", ".", "--first", "--yes")

	// THEN the chapters appear in the new order.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	ch3Idx := strings.Index(content, "ch3.md")
	ch1Idx := strings.Index(content, "ch1.md")
	if ch3Idx < 0 || ch1Idx < 0 {
		t.Fatalf("expected ch3.md and ch1.md in binder\ncontent: %s", content)
	}
	if ch3Idx >= ch1Idx {
		t.Errorf("expected ch3.md to come before ch1.md after move --first\ncontent: %s", content)
	}
}

// Moving a chapter moves its entire sub-chapter tree with it.
// Source: specs/001-prosemark-binder/US4-move-node.txt:11
func Test_Moving_a_chapter_moves_its_entire_sub_chapter_tree_with_it(t *testing.T) {
	// GIVEN a binder with a chapter that has nested sub-chapters.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Part One](part1.md)\n"+
			"  - [Chapter One](ch1.md)\n"+
			"    - [Section A](sec-a.md)\n"+
			"- [Part Two](part2.md)\n")
	writeFile(t, dir, "part1.md", "")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "sec-a.md", "")
	writeFile(t, dir, "part2.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author moves that chapter to a different location.
	result := runMove(t, binderPath, "ch1.md", "part2.md", "--yes")

	// THEN the chapter and all its sub-chapters appear together at the destination.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	part2Idx := strings.Index(content, "part2.md")
	ch1Idx := strings.Index(content, "ch1.md")
	secAIdx := strings.Index(content, "sec-a.md")
	if part2Idx < 0 || ch1Idx < 0 || secAIdx < 0 {
		t.Fatalf("expected all entries in binder\ncontent: %s", content)
	}
	// ch1 and sec-a should appear after part2 (i.e., nested under it)
	if ch1Idx <= part2Idx {
		t.Errorf("expected ch1.md after part2.md\ncontent: %s", content)
	}
	if secAIdx <= ch1Idx {
		t.Errorf("expected sec-a.md after ch1.md (subtree preserved)\ncontent: %s", content)
	}
}

// Moving a chapter into one of its own descendants is rejected.
// Source: specs/001-prosemark-binder/US4-move-node.txt:20
func Test_Moving_a_chapter_into_one_of_its_own_descendants_is_rejected(t *testing.T) {
	// GIVEN a binder where chapter "A" contains chapter "B".
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Chapter A](ch-a.md)\n"+
			"  - [Chapter B](ch-b.md)\n")
	writeFile(t, dir, "ch-a.md", "")
	writeFile(t, dir, "ch-b.md", "")
	binderPath := dir + "/_binder.md"
	before := readFile(t, binderPath)

	// WHEN the author tries to move "A" to be under "B".
	result := runMove(t, binderPath, "ch-a.md", "ch-b.md", "--yes")

	// THEN a "circular move" error is returned.
	if result.OK {
		t.Fatalf("expected non-zero exit for cycle detection\nstdout: %s", result.Stdout)
	}
	if !strings.Contains(result.Stdout, `"OPE003"`) {
		t.Errorf("expected OPE003 cycle error\nstdout: %s", result.Stdout)
	}
	// THEN the binder is unchanged.
	after := readFile(t, binderPath)
	if before != after {
		t.Errorf("expected binder unchanged on cycle error\nbefore: %s\nafter: %s", before, after)
	}
}

// Moving a chapter that uses footnote-style links preserves its link format.
// Source: specs/001-prosemark-binder/US4-move-node.txt:30
func Test_Moving_a_chapter_that_uses_footnote_style_links_preserves_its_link_format(t *testing.T) {
	// GIVEN a binder with a chapter that uses a footnote-style link.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Part](part.md)\n"+
			"  - [Chapter][ch-ref]\n"+
			"- [Other](other.md)\n\n"+
			"[ch-ref]: chapter.md\n")
	writeFile(t, dir, "part.md", "")
	writeFile(t, dir, "chapter.md", "")
	writeFile(t, dir, "other.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author moves that chapter to a different location.
	result := runMove(t, binderPath, "chapter.md", ".", "--yes")

	// THEN the moved chapter still uses its footnote-style link at the new location.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, "[Chapter][ch-ref]") {
		t.Errorf("expected footnote-style link '[Chapter][ch-ref]' preserved after move\ncontent: %s", content)
	}
	if !strings.Contains(content, "[ch-ref]: chapter.md") {
		t.Errorf("expected footnote definition '[ch-ref]: chapter.md' preserved\ncontent: %s", content)
	}
}

// Moving a chapter with a tooltip preserves the tooltip text.
// Source: specs/001-prosemark-binder/US4-move-node.txt:39
func Test_Moving_a_chapter_with_a_tooltip_preserves_the_tooltip_text(t *testing.T) {
	// GIVEN a binder with a chapter whose link has a tooltip.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Part One](part1.md)\n"+
			"  - [Chapter One](ch1.md \"Introduction chapter\")\n"+
			"- [Part Two](part2.md)\n")
	writeFile(t, dir, "part1.md", "")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "part2.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author moves that chapter to a different location.
	result := runMove(t, binderPath, "ch1.md", "part2.md", "--yes")

	// THEN the moved chapter's link still has the tooltip text at the new location.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, `"Introduction chapter"`) {
		t.Errorf("expected tooltip text 'Introduction chapter' to be preserved after move\ncontent: %s", content)
	}
	part2Idx := strings.Index(content, "part2.md")
	tooltipIdx := strings.Index(content, "Introduction chapter")
	if part2Idx < 0 || tooltipIdx < 0 {
		t.Fatalf("expected part2.md and tooltip in binder\ncontent: %s", content)
	}
	if tooltipIdx <= part2Idx {
		t.Errorf("expected tooltip chapter to appear after part2.md (nested under it)\ncontent: %s", content)
	}
}

// Moved chapter uses the indentation style of its new sibling group.
// Source: specs/001-prosemark-binder/US4-move-node.txt:48
func Test_Moved_chapter_uses_the_indentation_style_of_its_new_sibling_group(t *testing.T) {
	// GIVEN a binder where the destination section uses a different indentation style than the source section.
	dir := t.TempDir()
	// Source uses 2-space indent; destination uses tab indent.
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Part One](part1.md)\n"+
			"  - [Chapter One](ch1.md)\n"+
			"- [Part Two](part2.md)\n"+
			"\t- [Chapter Two](ch2.md)\n")
	writeFile(t, dir, "part1.md", "")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "part2.md", "")
	writeFile(t, dir, "ch2.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author moves a chapter to the destination section.
	result := runMove(t, binderPath, "ch1.md", "part2.md", "--yes")

	// THEN the moved chapter uses the destination section's indentation style.
	if !result.OK {
		t.Fatalf("expected exit 0\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, "\t- [Chapter One](ch1.md)") {
		t.Errorf("expected moved chapter to use tab indentation (matching Part Two's children)\ncontent: %q", content)
	}
}

// Moving a chapter with non-structural text destroys that text with a warning.
// Source: specs/001-prosemark-binder/US4-move-node.txt:57
func Test_Moving_a_chapter_with_non_structural_text_destroys_that_text_with_a_warning(t *testing.T) {
	// GIVEN a binder with a chapter entry that has additional descriptive text after its link.
	dir := t.TempDir()
	writeFile(t, dir, "_binder.md",
		"<!-- prosemark-binder:v1 -->\n\n"+
			"- [Part One](part1.md)\n"+
			"  - [ ] [Chapter One](ch1.md)\n"+
			"- [Part Two](part2.md)\n")
	writeFile(t, dir, "part1.md", "")
	writeFile(t, dir, "ch1.md", "")
	writeFile(t, dir, "part2.md", "")
	binderPath := dir + "/_binder.md"

	// WHEN the author moves that chapter.
	result := runMove(t, binderPath, "ch1.md", "part2.md", "--yes")

	// THEN the chapter appears at the destination without the additional text.
	if !result.OK {
		t.Fatalf("expected exit 0 (non-structural content is a warning)\nstdout: %s\nstderr: %s", result.Stdout, result.Stderr)
	}
	content := readFile(t, binderPath)
	if !strings.Contains(content, "ch1.md") {
		t.Fatalf("expected ch1.md at destination\ncontent: %s", content)
	}
	// The checkbox prefix [ ] should be destroyed
	if strings.Contains(content, "[ ] [Chapter One]") {
		t.Errorf("expected non-structural '[ ]' prefix to be removed\ncontent: %s", content)
	}
	// THEN a "non-structural content destroyed" warning is included in the result.
	if !strings.Contains(result.Stdout, `"OPW003"`) {
		t.Errorf("expected OPW003 non-structural-content-destroyed warning\nstdout: %s", result.Stdout)
	}
}
